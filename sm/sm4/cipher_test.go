package sm4

import (
	"bytes"
	"fmt"
	"log"
	"testing"
)

func TestBlockBase(t *testing.T) {
	var tests = []struct {
		key   []byte
		msg   []byte
		want  []byte
		isEnc bool
	}{
		{
			key:   []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			msg:   []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			want:  []byte{0x68, 0x1E, 0xDF, 0x34, 0xD2, 0x06, 0x96, 0x5E, 0x86, 0xB3, 0xE9, 0x4F, 0x53, 0x6E, 0x42, 0x46},
			isEnc: true,
		},
		{
			key:   []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			msg:   []byte{0x68, 0x1E, 0xDF, 0x34, 0xD2, 0x06, 0x96, 0x5E, 0x86, 0xB3, 0xE9, 0x4F, 0x53, 0x6E, 0x42, 0x46},
			want:  []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			isEnc: false,
		},
	}
	for _, test := range tests {
		block, err := NewCipher(test.key)
		if err != nil {
			t.Errorf("new cipher failed:%s\n", err.Error())
			continue
		}
		dst := make([]byte, 16)
		if test.isEnc {
			block.Encrypt(dst, test.msg)
		} else {
			block.Decrypt(dst, test.msg)
		}
		if !bytes.Equal(test.want, dst) {
			t.Errorf("TestBlockBase failed:\n key:%v\n msg:%v\n want:%v\n actual:%v\n", test.key, test.msg, test.want, dst)
		}
	}
}

func TestSM4(t *testing.T) {
	key := []byte("1234567890abcdef")
	fmt.Printf("key = %v\n", key)
	data := []byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10}
	fmt.Printf("key = %v\n", key)
	fmt.Printf("data = %x\n", data)
	c, err := NewCipher(key)
	if err != nil {
		log.Fatal(err)
	}
	d0 := make([]byte, 16)
	c.Encrypt(d0, data)
	fmt.Printf("d0 = %x\n", d0)
	d1 := make([]byte, 16)
	c.Decrypt(d1, d0)
	fmt.Printf("d1 = %x\n", d1)
}
